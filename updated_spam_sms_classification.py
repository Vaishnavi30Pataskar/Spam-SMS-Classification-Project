# -*- coding: utf-8 -*-
"""Updated_Spam_SMS_Classification.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GYw4maKoHraG5oesmfJjWj1jVCOGs2N_
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report, precision_score, recall_score, f1_score
from sklearn.pipeline import Pipeline

# Set random seed for reproducibility
np.random.seed(42)

# Function to load and preprocess data
def load_and_preprocess_data(file_path):
    """
    Load data from CSV file and preprocess it for model training

    Args:
        file_path: Path to the CSV file

    Returns:
        Preprocessed data with 'spam' converted to 0 and 'ham' to 1
    """
    # Load data from CSV
    df = pd.read_csv('mail_data.csv')

    # Replace any NaN values with empty strings
    data = df.where((pd.notnull(df)), '')

    # Convert 'spam' to 0 and 'ham' to 1 for binary classification
    data.loc[data['Category'] == 'spam', 'Category'] = 0
    data.loc[data['Category'] == 'ham', 'Category'] = 1

    return data

# Function to split data into training and testing sets
def split_data(data):
    """
    Split data into features (X) and target (Y) and then into train and test sets

    Args:
        data: Preprocessed DataFrame

    Returns:
        X_train, X_test, Y_train, Y_test: Split datasets
    """
    # Extract features (messages) and target (category)
    X = data['Message']
    Y = data['Category']

    # Convert target to integer type
    Y = Y.astype('int')

    # Split data into training (80%) and testing (20%) sets
    X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=42)

    return X_train, X_test, Y_train, Y_test

# Function to build and train the model
def build_and_train_model(X_train, Y_train):
    """
    Build a pipeline with TF-IDF vectorizer and Logistic Regression model, then train it

    Args:
        X_train: Training features
        Y_train: Training targets

    Returns:
        Trained model and vectorizer
    """
    # Create a pipeline with TF-IDF vectorizer and Logistic Regression
    pipeline = Pipeline([
        ('tfidf', TfidfVectorizer(min_df=1, stop_words='english', lowercase=True)),
        ('classifier', LogisticRegression(max_iter=1000, C=1.0))
    ])

    # Train the model
    pipeline.fit(X_train, Y_train)

    return pipeline

# Function to evaluate the model
def evaluate_model(model, X_train, Y_train, X_test, Y_test):
    """
    Evaluate model performance on training and testing data

    Args:
        model: Trained model
        X_train, Y_train: Training data
        X_test, Y_test: Testing data

    Returns:
        Dictionary with evaluation metrics
    """
    # Predict on training data
    Y_train_pred = model.predict(X_train)
    train_accuracy = accuracy_score(Y_train, Y_train_pred)

    # Predict on testing data
    Y_test_pred = model.predict(X_test)
    test_accuracy = accuracy_score(Y_test, Y_test_pred)

    # Calculate additional metrics for test data
    precision = precision_score(Y_test, Y_test_pred)
    recall = recall_score(Y_test, Y_test_pred)
    f1 = f1_score(Y_test, Y_test_pred)

    # Generate confusion matrix
    cm = confusion_matrix(Y_test, Y_test_pred)

    # Get classification report with a more compact format
    report = classification_report(Y_test, Y_test_pred, target_names=['Spam', 'Ham'], digits=3)

    return {
        'train_accuracy': train_accuracy,
        'test_accuracy': test_accuracy,
        'precision': precision,
        'recall': recall,
        'f1_score': f1,
        'confusion_matrix': cm,
        'classification_report': report,
        'Y_test': Y_test,
        'Y_test_pred': Y_test_pred
    }

# Function to visualize confusion matrix
def plot_confusion_matrix(cm):
    """
    Plot confusion matrix as a heatmap

    Args:
        cm: Confusion matrix
    """
    plt.figure(figsize=(5, 4))
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
                xticklabels=['Spam', 'Ham'],
                yticklabels=['Spam', 'Ham'])
    plt.ylabel('True Label')
    plt.xlabel('Predicted Label')
    plt.title('Confusion Matrix')
    plt.tight_layout()
    plt.show()

# Function to visualize class distribution
def plot_class_distribution(data):
    """
    Plot the distribution of spam and ham messages

    Args:
        data: Preprocessed DataFrame
    """
    plt.figure(figsize=(6, 4))

    # Count the occurrences of each category
    category_counts = data['Category'].value_counts().sort_index()
    labels = ['Spam', 'Ham']

    # Create bar chart
    sns.barplot(x=labels, y=category_counts.values)
    plt.title('Distribution of Messages')
    plt.xlabel('Category')
    plt.ylabel('Count')

    # Add count labels on top of bars
    for i, count in enumerate(category_counts.values):
        plt.text(i, count + 30, str(count), ha='center', fontsize=9)

    plt.tight_layout()
    plt.show()

# Function to visualize model performance metrics
def plot_model_metrics(metrics):
    """
    Plot model performance metrics

    Args:
        metrics: Dictionary with evaluation metrics
    """
    plt.figure(figsize=(7, 4))

    # Create bar chart for accuracy, precision, recall, and F1 score
    metric_names = ['Train Acc', 'Test Acc', 'Precision', 'Recall', 'F1']
    metric_values = [
        metrics['train_accuracy'],
        metrics['test_accuracy'],
        metrics['precision'],
        metrics['recall'],
        metrics['f1_score']
    ]

    # Create bar chart with smaller width
    sns.barplot(x=metric_names, y=metric_values, width=0.6)
    plt.title('Model Metrics', fontsize=11)
    plt.xlabel('Metric', fontsize=10)
    plt.ylabel('Score', fontsize=10)
    plt.ylim(0, 1)

    # Add values on top of bars with smaller font
    for i, value in enumerate(metric_values):
        plt.text(i, value + 0.01, f'{value:.3f}', ha='center', fontsize=8)

    plt.xticks(fontsize=9)
    plt.yticks(fontsize=9)
    plt.tight_layout()
    plt.show()

# Function to classify new input messages
def classify_message(model, message):
    """
    Classify a new message as spam or ham

    Args:
        model: Trained model
        message: Text message to classify

    Returns:
        Classification result (0 for spam, 1 for ham)
    """
    # Predict using the model
    prediction = model.predict([message])[0]

    return prediction

# Main function to run the program
def main():
    # Load and preprocess data
    print("Loading and preprocessing data...")
    data = load_and_preprocess_data('mail_data.csv')

    # Print basic info about the dataset
    print("\nDataset Information:")
    print(f"Total number of messages: {len(data)}")
    spam_count = len(data[data['Category'] == '0'])
    ham_count = len(data[data['Category'] == '1'])
    print(f"Number of spam messages: {spam_count}")
    print(f"Number of ham messages: {ham_count}")

    # Split the data
    print("\nSplitting data into training and testing sets...")
    X_train, X_test, Y_train, Y_test = split_data(data)
    print(f"Training set size: {len(X_train)}")
    print(f"Testing set size: {len(X_test)}")

    # Build and train the model
    print("\nBuilding and training the model...")
    model = build_and_train_model(X_train, Y_train)

    # Evaluate the model
    print("\nEvaluating model performance...")
    metrics = evaluate_model(model, X_train, Y_train, X_test, Y_test)

    # Print evaluation results
    print("\nModel Evaluation Results:")
    print(f"Training Accuracy: {metrics['train_accuracy']:.4f}")
    print(f"Testing Accuracy: {metrics['test_accuracy']:.4f}")
    print(f"Precision: {metrics['precision']:.4f}")
    print(f"Recall: {metrics['recall']:.4f}")
    print(f"F1 Score: {metrics['f1_score']:.4f}")

    print("\nClassification Report:")
    print(metrics['classification_report'])

    # Visualize results
    print("\nGenerating visualizations...")
    plot_confusion_matrix(metrics['confusion_matrix'])
    plot_class_distribution(data)
    plot_model_metrics(metrics)

    # Interactive message classification
    print("\n=== SMS Spam Classifier ===")
    while True:
        # Get user input
        user_input = input("\nEnter a message to classify (or 'q' to quit): ")

        if user_input.lower() == 'q':
            break

        # Classify the input message
        result = classify_message(model, user_input)

        # Display the result
        if result == 1:
            print("Result: HAM (Not Spam)")
        else:
            print("Result: SPAM")

# Run the main function if the script is executed directly
if __name__ == "__main__":
    main()
